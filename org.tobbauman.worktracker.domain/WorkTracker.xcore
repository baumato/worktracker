@Ecore(nsURI="org.tobbaumann.wt.domain/1.0")
@GenModel(
	editPluginID="org.tobbaumann.worktracker.domain.edit",
	editDirectory="/org.tobbaumann.worktracker.domain.edit/src",
	editorPluginID="org.tobbaumann.worktracker.domain.editor",
	editorDirectory="/org.tobbaumann.worktracker.domain.editor/src"
)
package org.tobbaumann.wt.domain

import java.util.Date
import java.lang.String
import java.text.SimpleDateFormat
import org.tobbaumann.wt.domain.impl.TimeSpanHelper
import org.eclipse.emf.common.util.BasicEList
import com.google.common.base.Strings
import org.eclipse.emf.ecore.util.EcoreUtil

annotation "http://www.eclipse.org/emf/2002/Ecore" as Ecore
annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

interface Comparable wraps java.lang.Comparable<WorkItem>{}

class Activities {
	contains Activity[] activities
		
	op Activity[] getMostUsedActivities(int numberOfActivities) {
		return new BasicEList(activities.sortBy([occurrenceFrequency]).take(numberOfActivities).toList)
	}
}

class Activity {
	String ^id
	String name
	long occurrenceFrequency
}



class WorkItem extends Comparable {
	id String ^id
	refers Activity activity
	derived String activityName get {
		return if (activity != null) activity.name else null
	}
	Date start
	Date end
	
	contains derived TimeSpan duration get {
		val TimeSpan ts = DomainFactory::eINSTANCE.createTimeSpan
		val Date s = if (start == null) new Date() else start
		val Date e = if (end == null) s else end
		val TimeSpanHelper h = TimeSpanHelper::getInstance(s, e)
		ts.millis = h.inSeconds * 1000
		return ts
	}
	
	String description
	
	op int compareTo(WorkItem wi) {
		return start.compareTo(wi.start)
	}
}

class WorkItemSummary {
	refers WorkItem[] workItems
	
	derived String activityName get {
		if (workItems.empty) {
			return null
		}
		return workItems.get(0).activityName
	}
	
	contains derived TimeSpan sumOfDurations get {
		val TimeSpan ts = DomainFactory::eINSTANCE.createTimeSpan
		ts.millis = workItems.map([it | it.duration.millis]).reduce([a, b | a + b])
		return ts
	}
	
	derived String[] sumOfDescriptions get {
		return new BasicEList(workItems.map([Strings::nullToEmpty(description)]))
	}
}

class TimeSpan {
	long millis
	
	derived int seconds get {
		return ((millis / 1000) % 60).intValue		
	}
	
	derived int minutes get {
		return ((millis / 1000 / 60) % 60).intValue
	}
	
	derived int hours get {
		return ((millis / 1000 / 60 / 60) % 24).intValue
	}
	
	derived int days get {
		return ((millis / 1000 / 60 / 60 / 24) % 7).intValue
	}
	
	derived int weeks get {
		return (millis / 1000 / 60 / 60 / 24 / 7).intValue
	}
	
	op long inSeconds() {
		return millis / 1000
	}
	
	op long inMinutes() {
		return seconds / 60
	}
	
	op long inHours() {
		return inMinutes / 60
	}
	
	op long inDays() {
		return inHours / 24
	}
	
	op long inWeeks() {
		return inDays / 7
	}
	
	op String asString() {
		val StringBuilder s = new StringBuilder();
        if(weeks > 0) s.append(weeks + " w  ");
        if(days > 0) s.append(days + " d  ");
        if(hours > 0) s.append(hours + " h  ");
        if(minutes > 0) s.append(minutes + " m  ");
        if(seconds> 0) s.append(seconds+ " s  ");
        if (s.toString.empty) {
        	s.append("0 s")
        }
        return s.toString.trim;
	}
}

type Date wraps java.util.Date
create {
	try {
		return new SimpleDateFormat("yyyy-MM-dd").parse(it)
	} catch (RuntimeException e) {
		throw e;
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
}
convert {
	try {
		return new SimpleDateFormat("yyyy-MM-dd").format(it)
	} catch (RuntimeException e) {
		throw e;
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
}
